<?php

class Debug{
    
    // Release version and codename
    const VERSION = '1.0.5';

    // Log message types
    const ERROR = 'ERROR';
    const DEBUG = 'DEBUG';
    const INFO = 'INFO';

    // Common environment type constants for consistency and convenience
    const PRODUCTION = 'production';
    const STAGING = 'staging';
    const TESTING = 'testing';
    const DEVELOPMENT = 'development';

    const DIRECTORY_SEPARATOR = '/';

    // Set our base path
    public static $base_url = '/';

    // Are magic quotes enabled?
    public static $magic_quotes = FALSE;

    // Config object
    public static $config;
    
    // To stop the class from being loaded in more than once
    protected static $_init = FALSE;
    
    // Are we displaying errors?
    public static $errors = TRUE;
    
    // Our character set, may differ for foreign language implementations
    public static $charset = 'UTF-8';
    
    public static $php_errors = array(
        E_ERROR             => 'Fatal Error',
        E_USER_ERROR        => 'User Error',
        E_PARSE             => 'Parse Error',
        E_WARNING           => 'Warning',
        E_USER_WARNING      => 'User Warning',
        E_STRICT            => 'Strict',
        E_NOTICE            => 'Notice',
        E_RECOVERABLE_ERROR => 'Recoverable Error',
    );
    
    public static $shutdown_errors = array(
        E_PARSE, 
        E_ERROR, 
        E_USER_ERROR, 
        E_COMPILE_ERROR
    );
    
    public static function init(){
        
        if (self::$_init){
            // Do not allow execution twice
            return;
        }
        
        if (defined('E_DEPRECATED')){
            // E_DEPRECATED only exists in PHP >= 5.3.0
            self::$php_errors[E_DEPRECATED] = 'Deprecated';
        }

        if (self::$errors === TRUE){
            
            set_exception_handler(array('Debug', 'exception_handler'));
            set_error_handler(array('Debug', 'error_handler'));
        
        }
        
        register_shutdown_function(array('Debug', 'shutdown_handler'));
        
        if (ini_get('register_globals')){
            // Reverse the effects of register_globals
            self::globals();
        }

        if (function_exists('mb_internal_encoding')){
            // Set the MB extension encoding to the same character set
            mb_internal_encoding(self::$charset);
        }
        
        self::$magic_quotes = (bool) get_magic_quotes_gpc();
        
        // Sanitize all request variables
        $_GET       = self::sanitize($_GET);
        $_POST      = self::sanitize($_POST);
        $_COOKIE    = self::sanitize($_COOKIE);
        
        //  We have now been executed
        self::$_init = TRUE;
        
    }
    
    /**
    * 
    * Reverts the effects of the `register_globals` PHP setting by unsetting
    * all global varibles except for the default super globals (GPCS, etc).
    *
    */
    
    public static function globals(){
        
        $global_list = array('_COOKIE', '_ENV', '_GET', '_FILES', '_POST', '_REQUEST', '_SERVER', '_SESSION', 'GLOBALS');
    
        if (isset($_REQUEST['GLOBALS']) OR isset($_FILES['GLOBALS'])){
            
            // Prevent malicious GLOBALS overload attack
            echo "Global variable overload attack detected! Request aborted.\n";

            // Exit with an error status
            exit(1);
        }

        // Get the variable names of all globals
        $global_variables = array_keys($GLOBALS);

        // Remove the standard global variables from the list
        $global_variables = array_diff($global_variables, $gobal_list);

        foreach ($global_variables as $name){
            // Unset the global variable, effectively disabling register_globals
            unset($GLOBALS[$name]);
        }
        
        return;
        
    }
    
    /**
    * 
    * Recursively sanitizes an input variable
    *
    * - Strips slashes if magic quotes are enabled
    * - Normalizes all newlines to LF
    * 
    */
    
    public static function sanitize($value){
        
        if(is_array($value) OR is_object($value)){
            
            foreach ($value as $key => $val){
                // Recursively clean each value
                $value[$key] = self::sanitize($val);
            }
            
        }elseif(is_string($value)){
            
            if (self::$magic_quotes === TRUE){
                // Remove slashes added by magic quotes
                $value = stripslashes($value);
            }

            if (strpos($value, "\r") !== FALSE){
                // Standardize newlines
                $value = str_replace(array("\r\n", "\r"), "\n", $value);
            }
        }

        return $value;
    
    }
    
    /**
    * 
    * Catches errors that are not caught by the error handler, such as E_PARSE.
    *
    * @uses Kohana::exception_handler
    * @return void
    * 
    */
    
    public static function shutdown_handler(){
        
        if (!Debug::$_init){
            // Early exit if we havent been invoked
            return;
        }

        if (self::$errors AND $error = error_get_last() AND in_array($error['type'], self::$shutdown_errors)){

            // Clean the output buffer
            ob_get_level() and ob_clean();

            // Fake an exception for nice debugging
            Debug::exception_handler(new ErrorException($error['message'], $error['type'], 0, $error['file'], $error['line']));

            // Shutdown now to avoid a "death loop"
            exit(1);
        
        }
    }

    /**
    * 
    * PHP error handler, converts all errors into ErrorExceptions. This handler
    * respects error_reporting settings.
    * 
    */

    public static function error_handler($code, $error, $file = NULL, $line = NULL){

        if (error_reporting() & $code){

            // This error is not suppressed by current error reporting settings
            // Convert the error into an ErrorException
            throw new ErrorException($error, $code, 0, $file, $line);
        
        }

        // Do not execute the PHP error handler
        return TRUE;
        
    }

    /**
    * 
    * Can be used to replace document root or system paths for a shorter name.
    * 
    * !! NOT CURRENTLY USED !!
    * 
    */
    
    public static function debug_path($file){

        return $file;
    }

    /**
    * 
    * Returns an array of HTML strings that represent each step in the backtrace.
    *
    */
    
    public static function trace(array $trace = NULL){
        
        if ($trace === NULL){
            // Start a new trace
            $trace = debug_backtrace();
        }

        // Non-standard function calls
        $statements = array('include', 'include_once', 'require', 'require_once');

        $output = array();
    
        foreach ($trace as $step){
            
            if (!isset($step['function'])){
                // Invalid trace step
                continue;
            }

            if (isset($step['file']) AND isset($step['line'])){
                // Include the source of this step
                $source = Debug::debug_source($step['file'], $step['line']);
            }

            if (isset($step['file'])){
                
                $file = $step['file'];

                if (isset($step['line'])){
                    $line = $step['line'];
                }
            }

            // function()
            $function = $step['function'];

            if (in_array($step['function'], $statements)){
                if (empty($step['args'])){
                    // No arguments
                    $args = array();
                }else{
                    // Sanitize the file path
                    $args = array($step['args'][0]);
                }
            }elseif (isset($step['args'])){
            
                if (!function_exists($step['function']) OR strpos($step['function'], '{closure}') !== FALSE){
                    // Introspection on closures or language constructs in a stack trace is impossible
                    $params = NULL;
                }else{
                    if (isset($step['class'])){
                        if (method_exists($step['class'], $step['function'])){
                            $reflection = new ReflectionMethod($step['class'], $step['function']);
                        }else{
                            $reflection = new ReflectionMethod($step['class'], '__call');
                        }
                    }else{
                        $reflection = new ReflectionFunction($step['function']);
                    }

                    // Get the function parameters
                    $params = $reflection -> getParameters();
                }

                $args = array();

                foreach ($step['args'] as $i => $arg){
                    if (isset($params[$i])){
                        // Assign the argument by the parameter name
                        $args[$params[$i] -> name] = $arg;
                    }else{
                        // Assign the argument by number
                        $args[$i] = $arg;
                    }
                }
            }

            if (isset($step['class'])){
                // Class->method() or Class::method()
                $function = $step['class'].$step['type'].$step['function'];
            }

            $output[] = array(
                'function'  => $function,
                'args'      => isset($args)   ? $args : NULL,
                'file'      => isset($file)   ? $file : NULL,
                'line'      => isset($line)   ? $line : NULL,
                'source'    => isset($source) ? $source : NULL,
            );

            unset($function, $args, $file, $line, $source);
        
        }

        return $output;
    
    }

    /**
    * 
    * Returns an HTML string of information about a single variable.
    * 
    */
    
    public static function dump($value, $length = 128){
        return self::_dump($value, $length);
    }

    protected static function _dump( & $var, $length = 128, $level = 0){
        
        if ($var === NULL){
            return 'NULL';
        }elseif(is_bool($var)){
            return 'bool '.($var ? 'TRUE' : 'FALSE');
        }elseif (is_float($var)){
            return 'float '.$var;
        }elseif (is_resource($var)){
            
            if (($type = get_resource_type($var)) === 'stream' AND $meta = stream_get_meta_data($var)){
                
                $meta = stream_get_meta_data($var);

                if (isset($meta['uri'])){
                    
                    $file = $meta['uri'];

                    if (function_exists('stream_is_local')){
                        // Only exists on PHP >= 5.2.4
                        if (stream_is_local($file)){
                            $file = self::debug_path($file);
                        }
                    }

                    return 'resource<span>('.$type.')</span> '.htmlspecialchars($file, ENT_NOQUOTES, self::$charset);
                }
            
            }else{
                return 'resource<span>('.$type.')</span>';
            }
        
        }elseif(is_string($var)){
            
            // Clean invalid multibyte characters. iconv is only invoked
            // if there are non ASCII characters in the string, so this
            // isn't too much of a hit.
            $var = $var;

            if (strlen($var) > $length){
                // Encode the truncated string
                //$str = htmlspecialchars(substr($var, 0, $length), ENT_NOQUOTES, self::$charset).'&nbsp;&hellip;';
                $str = $var.'&nbsp;&hellip;';
            }else{
                // Encode the string
                $str = htmlspecialchars($var, ENT_NOQUOTES, self::$charset);
            }

            return 'string<span>('.strlen($var).')</span> "'.$str.'"';
        
        }elseif(is_array($var)){
            
            $output = array();

            // Indentation for this variable
            $space = str_repeat($s = ' ', $level);

            static $marker;

            if ($marker === NULL){
                // Make a unique marker
                $marker = uniqid("\x00");
            }

            if(empty($var)){
                // Do nothing
            }elseif(isset($var[$marker])){
                $output[] = "(\n$space$s*RECURSION*\n$space)";
            }elseif ($level < 5){
                
                $output[] = "<span>(";

                $var[$marker] = TRUE;
                
                foreach ($var as $key => & $val){
                    if ($key === $marker) continue;
                    if (!is_int($key)){
                        $key = '"'.htmlspecialchars($key, ENT_NOQUOTES, self::$charset).'"';
                    }
                    $output[] = "$space$s$key => ".self::_dump($val, $length, $level + 1);
                }
                
                unset($var[$marker]);

                $output[] = "$space)</span>";
            }else{
                // Depth too great
                $output[] = "(\n$space$s...\n$space)";
            }

            return 'array<span>('.count($var).')</span> '.implode("\n", $output);
        
        }elseif (is_object($var)){
            
            // Copy the object as an array
            $array = (array) $var;

            $output = array();

            // Indentation for this variable
            $space = str_repeat($s = ' ', $level);

            $hash = spl_object_hash($var);

            // Objects that are being dumped
            static $objects = array();

            if(empty($var)){
                // Do nothing
            }elseif (isset($objects[$hash])){
                $output[] = "{\n$space$s*RECURSION*\n$space}";
            }elseif ($level < 10){
                
                $output[] = "<code>{";
                $objects[$hash] = TRUE;
                
                foreach ($array as $key => & $val){
                    if ($key[0] === "\x00"){                    
                        // Determine if the access is protected or protected
                        $access = ($key[1] === '*' ? 'protected' : 'private');

                        // Remove the access level from the variable name
                        $key = substr($key, strrpos($key, "\x00") + 1);
                    }else{
                        $access = 'public';
                    }

                    $output[] = "$space$s$access $key => ".self::_dump($val, $length, $level + 1);
                }
                
                unset($objects[$hash]);

                $output[] = "$space}</code>";
            
            }else{
                // Depth too great
                $output[] = "{\n$space$s...\n$space}";
            }

            return 'object <span>'.get_class($var).'('.count($array).')</span> '.implode("\n", $output);
            
        }else{
            return gettype($var).' '.htmlspecialchars(print_r($var, TRUE), ENT_NOQUOTES, self::$charset);
        }
        
    }
    
    /**
    * Get a single line of text representing the exception:
    *
    * Error [ Code ]: Message ~ File [ Line ]
    *
    * @param object Exception
    * @return string
    */

    public static function exception_text(Exception $e){
        
        return sprintf('%s [ %s ]: %s ~ %s [ %d ]',
        get_class($e), $e -> getCode(), strip_tags($e -> getMessage()), self::debug_path($e -> getFile()), $e -> getLine());
        
    }

    /**
    * 
    * Inline exception handler, displays the error message, source of the
    * exception, and the stack trace of the error.
    *
    */
    public static function exception_handler(Exception $e){
        
        try {
            // Get the exception information
            $type    = get_class($e);
            $code    = $e -> getCode();
            $message = $e -> getMessage();
            $file    = $e -> getFile();
            $line    = $e -> getLine();

            // Create a text version of the exception
            $error = self::exception_text($e);

            // Get the exception backtrace
            $trace = $e -> getTrace();

            if($e instanceof ErrorException){                
                if(isset(self::$php_errors[$code])){
                    // Use the human-readable error name
                    $code = self::$php_errors[$code];
                }
            }

            if(version_compare(PHP_VERSION, '5.3', '<')){
                
                // Workaround for a bug in ErrorException::getTrace() that exists in
                // all PHP 5.2 versions. @see http://bugs.php.net/bug.php?id=45895
                for ($i = count($trace) - 1; $i > 0; --$i){
                    if (isset($trace[$i - 1]['args'])){
                        
                        // Re-position the args
                        $trace[$i]['args'] = $trace[$i - 1]['args'];

                        // Remove the args
                        unset($trace[$i - 1]['args']);
                    }
                }
            }

            if (!headers_sent()){
                // Make sure the proper content type is sent with a 500 status
                header('Content-Type: text/html; charset='.self::$charset, TRUE, 500);
            }

            // -
            // Start building our error output
            // -
            
            // Start an output buffer
            ob_start();

            // Include the exception HTML
            include "errorView.php";

            // Display the contents of the output buffer
            echo ob_get_clean();   

            return TRUE;
        
        }catch (Exception $e){
            
            // Clean the output buffer if one exists
            ob_get_level() and ob_clean();

            // Display the exception text
            echo Debug::exception_text($e), "\n";

        }
    } 

    public static function chars($value, $double_encode = TRUE){
        return htmlspecialchars((string) $value, ENT_QUOTES, self::$charset, $double_encode);
    }

    /**
    * Returns an HTML string, highlighting a specific line of a file, with some
    * number of lines padded above and below.
    *
    * @param string file to open
    * @param integer line number to highlight
    * @param integer number of padding lines
    * @return string source of file
    * @return FALSE file is unreadable
    */

    public static function debug_source($file, $line_number, $padding = 8){
        
        if (!$file OR !is_readable($file)){
            // Continuing will cause errors
            return FALSE;
        }

        // Open the file and set the line position
        $file = fopen($file, 'r');
        $line = 0;

        // Set the reading range
        $range = array('start' => $line_number - $padding, 'end' => $line_number + $padding);

        // Set the zero-padding amount for line numbers
        $format = '% '.strlen($range['end']).'d';

        $source = '';
        
        while (($row = fgets($file)) !== FALSE){
        
            // Increment the line number
            if (++$line > $range['end']) break;

            if ($line >= $range['start']){
                
                // Make the row safe for output
                $row = htmlspecialchars($row, ENT_NOQUOTES, Debug::$charset);

                // Trim whitespace and sanitize the row
                $row = '<span class="number">'.sprintf($format, $line).'</span> '.$row;

                if ($line === $line_number){
                    // Apply highlighting to this row
                    $row = '<span class="line highlight">'.$row.'</span>';
                }else{
                    $row = '<span class="line">'.$row.'</span>';
                }

                // Add to the captured source
                $source .= $row;
            }
        }

        // Close the file
        fclose($file);

        return '<pre class="source"><code>'.$source.'</code></pre>';
    }

}
 
?>
