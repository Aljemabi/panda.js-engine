<?php

/** 
 * @package xml
 * @author Ricardo Alexandre Sismeiro <ricardo@sismeiro.com>
 * @version 1.0.0.0
 * @copyright Copyright (c) 2007, Ricardo Alexandre Sismeiro.
 * @license http://www.gnu.org/licenses/gpl.txt GNU GENERAL PUBLIC LICENSE
 * @link http://www.sismeiro.com/php/xml.phps 
 * 
 */

class xml {
    
    static $doc;
    static $filename;
    static $result;
    static $rootname;
    
   /* function __construct(){
        if (!$this->required_functions()){die();}
        $this->result=false;
    }*/

    private static function required_functions(){
       $result=true;
       $fun=array('simplexml_load_file','simplexml_load_string');       
       foreach ($fun as $name){
           if (!function_exists($name)) {
               $result=false;
               trigger_error('xml error - this class need some functions like '.$name,E_USER_WARNING);
           }
       }
       if (!$result) trigger_error('xml error - can\'t proceed',E_USER_ERROR);       
       return $result;
    }
    
    public static function load_string($string){
        if ($string!=''){
            $doc = simplexml_load_string($string);
            
            if (!is_object($doc)) trigger_error("xml error - could not create a simple xml object from the string [$string]",E_USER_WARNING);
            
            return $doc;
        }
        else {
            trigger_error("xml error - the parameter \$string is ''",E_USER_WARNING);
        }
    }
    
    
    private static function convert_simplexml_object2array(&$result,$root,$rootname='root'){             
        $n=count($root->children());    
        if ($n>0){
            if (!isset($result[$rootname]['@attributes'])){
                $result[$rootname]['@attributes']=array();
                foreach ($root->attributes() as $atr => $value)
                   $result[$rootname]['@attributes'][$atr] = (string) $value;                         
            }
            
            foreach ($root->children() as $child){
                 $name=$child->getName();     
                 self::convert_simplexml_object2array($result[$rootname][],$child,$name);                          
            }
        } else {                    
            $result[$rootname]=(array) $root;            
            if (!isset($result[$rootname]['@attributes']))
                $result[$rootname]['@attributes'] = array();            
        } 
    }
    
    private static function convert_array2simplexml_object($array,$doc=''){        
        if (is_array($array)){
            if (!is_object($doc)) $doc=self::$doc;
                        
            if ((isset($array['@attributes'])) && (count($array['@attributes'])>0)){                
                   foreach ($array['@attributes'] as $attribute => $value)
                       $doc -> addAttribute($attribute, utf8_encode($value));                           
                   unset($array['@attributes']);
            }
            
            foreach ($array as $key=>$value){
                if (is_numeric($key) && is_array($value)){
                    list($child)=array_keys($value);
                    if (is_array($value[$child][0])){$newchild=$doc->addChild($child);}
                    else {$newchild=$doc->addChild($child,utf8_encode($value[$child][0]));}
                    self::convert_array2simplexml_object($value[$child],$newchild);
                }
            }
        } 
        
        return $doc;        
    }
    
    public static function xml2array($filename, $save_result=false){
    	
    	self::$doc = simplexml_load_file($filename);   
        $result = json_encode(self::$doc);
        $result = json_decode($result, true);

        return $result; 
          
    }  
    
    public static function array2xml($array, $rootname){
                    
        $xml_string='<?xml version=\'1.0\' encoding=\'utf8\'?'.'>'.PHP_EOL;
        $xml_string.='<'.$rootname.'>';
        $xml_string.='</'.$rootname.'>';
        $doc = self::load_string($xml_string);           
        self::convert_array2simplexml_object($array, $doc);
        $result = $doc -> asXML();
        
        return $result;                    
    }
    
    public static function format($xml){  
    
		// add marker linefeeds to aid the pretty-tokeniser (adds a linefeed between all tag-end boundaries)
		$xml = preg_replace('/(>)(<)(\/*)/', "$1\n$2$3", $xml);
		
		// now indent the tags
		$token      = strtok($xml, "\n");
		$result     = ''; // holds formatted version as it is built
		$pad        = 0; // initial indent
		$matches    = array(); // returns from preg_matches()
		
		// scan each line and adjust indent based on opening/closing tags
		while ($token !== false){
		
			// 1. open and closing tags on same line - no change
			if (preg_match('/.+<\/\w[^>]*>$/', $token, $matches)){
			  	
			  	$indent = 0;
			
			// 2. closing tag - outdent now
			}elseif (preg_match('/^<\/\w/', $token, $matches)){
			  	
			  	$pad--;
			  	$pad--;
			  	
			// 3. opening tag - don't pad this one, only subsequent tags
			}elseif (preg_match('/^<\w[^>]*[^\/]>.*$/', $token, $matches)){
			  	
			  	$indent = 2;
			  	
			// 4. no indentation needed
			}else{
			  
			  $indent = 0; 
			
			}
			
			// pad the line with the required number of leading spaces
			$line    = str_pad($token, strlen($token)+$pad, ' ', STR_PAD_LEFT);
			$result .= $line . "\n"; // add to the cumulative result, with linefeed
			$token   = strtok("\n"); // get the next token
			$pad    += $indent; // update the pad size for subsequent lines    
		
		}
		
		return $result;

    }
    
}
?>